# Azure Pipelines - SemVer Release Pipeline
# Manual trigger only - for version management

trigger: none
pr: none

# Prevent parallel runs to avoid version conflicts
lockBehavior: sequential

parameters:
  - name: versionBump
    displayName: 'Version Bump Type'
    type: string
    default: 'patch'
    values:
      - major
      - minor
      - patch
  
  - name: preRelease
    displayName: 'Pre-release tag (optional, e.g., alpha, beta, rc)'
    type: string
    default: ''

  - name: generateChangelog
    displayName: 'Generate CHANGELOG from commits'
    type: boolean
    default: true

pool:
  vmImage: 'ubuntu-latest'

stages:
  # ============================================
  # Stage 1: Calculate New Version
  # ============================================
  - stage: CalculateVersion
    displayName: 'Calculate Version'
    jobs:
      - job: GetVersion
        displayName: 'Determine new version'
        steps:
          - checkout: self
            
          - task: NodeTool@0
            inputs:
              versionSpec: '20.x'
            displayName: 'Install Node.js'
            
          - script: |
              CURRENT_VERSION=$(node -p "require('./package.json').version")
              echo "Current version: $CURRENT_VERSION"
              
              # Remove any existing pre-release suffix for calculation
              BASE_VERSION=$(echo "$CURRENT_VERSION" | cut -d'-' -f1)
              
              # Parse version components
              IFS='.' read -r MAJOR MINOR PATCH <<< "$BASE_VERSION"
              
              # Calculate new version based on bump type
              case "${{ parameters.versionBump }}" in
                major)
                  NEW_VERSION="$((MAJOR + 1)).0.0"
                  ;;
                minor)
                  NEW_VERSION="${MAJOR}.$((MINOR + 1)).0"
                  ;;
                patch)
                  NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
                  ;;
              esac
              
              # Add pre-release tag if specified
              PRERELEASE="${{ parameters.preRelease }}"
              if [ -n "$PRERELEASE" ]; then
                NEW_VERSION="${NEW_VERSION}-${PRERELEASE}"
              fi
              
              echo "##vso[task.logissue type=warning]Bumping version: $CURRENT_VERSION → $NEW_VERSION"
              echo "##vso[task.setvariable variable=currentVersion;isOutput=true]$CURRENT_VERSION"
              echo "##vso[task.setvariable variable=newVersion;isOutput=true]$NEW_VERSION"
            name: calcVersion
            displayName: 'Calculate new version'

  # ============================================
  # Stage 2: Update Version & Create Tag
  # ============================================
  - stage: UpdateVersion
    displayName: 'Update & Tag'
    dependsOn: CalculateVersion
    variables:
      currentVersion: $[ stageDependencies.CalculateVersion.GetVersion.outputs['calcVersion.currentVersion'] ]
      newVersion: $[ stageDependencies.CalculateVersion.GetVersion.outputs['calcVersion.newVersion'] ]
    jobs:
      - job: UpdateAndTag
        displayName: 'Update package.json and create git tag'
        steps:
          - checkout: self
            persistCredentials: true
            fetchDepth: 0
            
          - task: NodeTool@0
            inputs:
              versionSpec: '20.x'
            displayName: 'Install Node.js'
            
          - script: |
              git config user.email "azure-pipelines@policytracker.eu"
              git config user.name "Azure Pipelines [Release]"
            displayName: 'Configure Git'
            
          - script: |
              echo "Updating version to $(newVersion)"
              npm version $(newVersion) --no-git-tag-version --allow-same-version
              npm install --package-lock-only
            displayName: 'Update package.json version'
            
          - script: |
              git add package.json package-lock.json
              git commit -m "chore(release): v$(newVersion) [skip ci]" || echo "No changes to commit"
            displayName: 'Commit version change'
            
          - script: |
              git tag -a "v$(newVersion)" -m "Release v$(newVersion)

              Version bump: ${{ parameters.versionBump }}
              Previous version: $(currentVersion)
              "
            displayName: 'Create annotated tag'
            
          - script: |
              git push origin HEAD:main
              git push origin "v$(newVersion)"
            displayName: 'Push changes and tag'
            
          - script: |
              echo "##vso[task.logissue type=warning]✅ Released v$(newVersion)"
              echo "Tag: v$(newVersion)"
              echo "View at: $(System.CollectionUri)$(System.TeamProject)/_git/$(Build.Repository.Name)?version=GTv$(newVersion)"
            displayName: 'Release summary'

  # ============================================
  # Stage 3: Generate Changelog (Optional)
  # ============================================
  - stage: GenerateChangelog
    displayName: 'Generate Changelog'
    dependsOn: UpdateVersion
    condition: and(succeeded(), eq('${{ parameters.generateChangelog }}', true))
    variables:
      newVersion: $[ stageDependencies.CalculateVersion.GetVersion.outputs['calcVersion.newVersion'] ]
    jobs:
      - job: Changelog
        displayName: 'Update CHANGELOG.md'
        steps:
          - checkout: self
            persistCredentials: true
            fetchDepth: 0
            
          - script: |
              git config user.email "azure-pipelines@policytracker.eu"
              git config user.name "Azure Pipelines [Release]"
              git pull origin main
            displayName: 'Configure Git and pull latest'
            
          - script: |
              # Get the previous tag
              PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
              
              echo "Previous tag: $PREV_TAG"
              echo "New version: $(newVersion)"
              
              # Get commits since last tag
              if [ -n "$PREV_TAG" ]; then
                COMMITS=$(git log ${PREV_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges --grep="^chore(release)" --invert-grep)
              else
                COMMITS=$(git log --pretty=format:"- %s (%h)" --no-merges -30)
              fi
              
              # Categorize commits
              FEATURES=$(echo "$COMMITS" | grep -E "^- feat" || true)
              FIXES=$(echo "$COMMITS" | grep -E "^- fix" || true)
              DOCS=$(echo "$COMMITS" | grep -E "^- docs" || true)
              CHORES=$(echo "$COMMITS" | grep -E "^- (chore|ci|build|refactor|style|test)" || true)
              OTHER=$(echo "$COMMITS" | grep -vE "^- (feat|fix|docs|chore|ci|build|refactor|style|test)" || true)
              
              # Build changelog entry
              {
                echo "## [$(newVersion)] - $(date +%Y-%m-%d)"
                echo ""
                
                if [ -n "$FEATURES" ]; then
                  echo "### Features"
                  echo "$FEATURES"
                  echo ""
                fi
                
                if [ -n "$FIXES" ]; then
                  echo "### Bug Fixes"
                  echo "$FIXES"
                  echo ""
                fi
                
                if [ -n "$DOCS" ]; then
                  echo "### Documentation"
                  echo "$DOCS"
                  echo ""
                fi
                
                if [ -n "$CHORES" ]; then
                  echo "### Maintenance"
                  echo "$CHORES"
                  echo ""
                fi
                
                if [ -n "$OTHER" ]; then
                  echo "### Other"
                  echo "$OTHER"
                  echo ""
                fi
                
                echo "---"
                echo ""
              } > CHANGELOG_NEW.md
              
              # Prepend to existing CHANGELOG or create new
              if [ -f CHANGELOG.md ]; then
                # Skip the header if it exists
                if head -1 CHANGELOG.md | grep -q "^# Changelog"; then
                  tail -n +3 CHANGELOG.md >> CHANGELOG_NEW.md
                  echo "# Changelog" > CHANGELOG.md
                  echo "" >> CHANGELOG.md
                  cat CHANGELOG_NEW.md >> CHANGELOG.md
                else
                  cat CHANGELOG.md >> CHANGELOG_NEW.md
                  mv CHANGELOG_NEW.md CHANGELOG.md
                fi
              else
                echo "# Changelog" > CHANGELOG.md
                echo "" >> CHANGELOG.md
                cat CHANGELOG_NEW.md >> CHANGELOG.md
              fi
              
              rm -f CHANGELOG_NEW.md
              
              echo "=== CHANGELOG Preview ==="
              head -50 CHANGELOG.md
            displayName: 'Generate changelog from commits'
            
          - script: |
              git add CHANGELOG.md
              git commit -m "docs: update CHANGELOG for v$(newVersion) [skip ci]" || echo "No changelog changes"
              git push origin HEAD:main || echo "Nothing to push"
            displayName: 'Commit and push changelog'
