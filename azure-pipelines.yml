# Azure Pipelines CI/CD for NestJS Backend
# GDPR Audit Backend API

trigger:
  branches:
    include:
      - main
  paths:
    exclude:
      - '*.md'
      - '.github/**'

pr:
  branches:
    include:
      - main

variables:
  nodeVersion: '20.x'
  npmCacheFolder: $(Pipeline.Workspace)/.npm
  # Queue configuration: 'postgres' (default, no Redis) or 'redis' (requires more RAM)
  queueType: 'postgres'
  # Docker Compose profile: '' (default), 'redis', or 'scaled'
  dockerProfile: ''

stages:
  # ============================================
  # Stage 1: Build & Test
  # ============================================
  - stage: Build
    displayName: 'Build & Test'
    jobs:
      # # Lint job
      # - job: Lint
      #   displayName: 'Lint'
      #   pool:
      #     vmImage: 'ubuntu-latest'
      #   steps:
      #     - task: NodeTool@0
      #       displayName: 'Install Node.js'
      #       inputs:
      #         versionSpec: $(nodeVersion)

      #     - task: Cache@2
      #       displayName: 'Cache npm packages'
      #       inputs:
      #         key: 'npm | "$(Agent.OS)" | package-lock.json'
      #         restoreKeys: |
      #           npm | "$(Agent.OS)"
      #         path: $(npmCacheFolder)

      #     - script: |
      #         npm ci --cache $(npmCacheFolder)
      #         chmod -R +x node_modules/.bin
      #       displayName: 'Install dependencies'

      #     - script: npx prisma generate
      #       displayName: 'Generate Prisma client'

      #     # - script: npm run lint
      #     #   displayName: 'Run ESLint'

      # # Format check job
      # - job: Format
      #   displayName: 'Format Check'
      #   pool:
      #     vmImage: 'ubuntu-latest'
      #   steps:
      #     - task: NodeTool@0
      #       displayName: 'Install Node.js'
      #       inputs:
      #         versionSpec: $(nodeVersion)

      #     - task: Cache@2
      #       displayName: 'Cache npm packages'
      #       inputs:
      #         key: 'npm | "$(Agent.OS)" | package-lock.json'
      #         restoreKeys: |
      #           npm | "$(Agent.OS)"
      #         path: $(npmCacheFolder)

      #     - script: |
      #         npm ci --cache $(npmCacheFolder)
      #         chmod -R +x node_modules/.bin
      #       displayName: 'Install dependencies'

      #     - script: npx prisma generate
      #       displayName: 'Generate Prisma client'

      #     # - script: npx prettier --check "src/**/*.ts" "test/**/*.ts"
      #     #   displayName: 'Check code formatting'

      # Unit Tests job
      - job: Test
        displayName: 'Unit Tests'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: $(nodeVersion)

          - task: Cache@2
            displayName: 'Cache npm packages'
            inputs:
              key: 'npm | "$(Agent.OS)" | package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: $(npmCacheFolder)

          - script: |
              npm ci --cache $(npmCacheFolder)
              chmod -R +x node_modules/.bin
            displayName: 'Install dependencies'

          - script: npx prisma generate
            displayName: 'Generate Prisma client'

          - script: npm run test:cov
            displayName: 'Run unit tests with coverage'

          - task: PublishCodeCoverageResults@2
            displayName: 'Publish code coverage'
            inputs:
              summaryFileLocation: '$(System.DefaultWorkingDirectory)/coverage/cobertura-coverage.xml'
            condition: succeededOrFailed()

          - task: PublishTestResults@2
            displayName: 'Publish test results'
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '**/junit.xml'
              failTaskOnFailedTests: true
            condition: succeededOrFailed()

      # Build job
      - job: BuildApp
        displayName: 'Build Application'
        dependsOn:
          # - Lint
          # - Format
          - Test
        condition: succeededOrFailed()
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: $(nodeVersion)

          - task: Cache@2
            displayName: 'Cache npm packages'
            inputs:
              key: 'npm | "$(Agent.OS)" | package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: $(npmCacheFolder)

          - script: |
              npm ci --cache $(npmCacheFolder)
              chmod -R +x node_modules/.bin
            displayName: 'Install dependencies'

          - script: npx prisma generate
            displayName: 'Generate Prisma client'

          - script: npm run build
            displayName: 'Build application'

          - publish: $(System.DefaultWorkingDirectory)/dist
            artifact: dist
            displayName: 'Publish build artifact'

      # E2E Tests job
      - job: E2E
        displayName: 'E2E Tests'
        dependsOn: BuildApp
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: $(nodeVersion)

          - task: Cache@2
            displayName: 'Cache npm packages'
            inputs:
              key: 'npm | "$(Agent.OS)" | package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: $(npmCacheFolder)

          - script: |
              npm ci --cache $(npmCacheFolder)
              chmod -R +x node_modules/.bin
            displayName: 'Install dependencies'

          - script: npx prisma generate
            displayName: 'Generate Prisma client'

          - download: current
            artifact: dist
            displayName: 'Download build artifact'

          - script: mv $(Pipeline.Workspace)/dist $(System.DefaultWorkingDirectory)/dist
            displayName: 'Restore dist artifact'

          - script: npm run test:e2e
            displayName: 'Run E2E tests'

  # ============================================
  # Stage 2: Deploy (only on main branch)
  # ============================================
  - stage: Deploy
    displayName: 'Deploy to Vultr'
    dependsOn: Build
    # Deploy even if tests fail, but only on main branch
    condition: and(not(canceled()), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    variables:
      - group: vultr-deployment
    jobs:
      - deployment: DeployProduction
        displayName: 'Deploy to Production'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'production'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                - script: |
                    # Setup SSH key
                    mkdir -p ~/.ssh
                    echo "$(VULTR_SSH_KEY)" | base64 -d > ~/.ssh/deploy_key
                    chmod 600 ~/.ssh/deploy_key
                    
                    # Add host to known_hosts
                    ssh-keyscan -H $(VULTR_HOST) >> ~/.ssh/known_hosts
                  displayName: 'Setup SSH Key'

                - script: |
                    # Copy project files to server
                    rsync -avz --delete \
                      --exclude 'node_modules' \
                      --exclude '.git' \
                      --exclude 'coverage' \
                      --exclude '.env' \
                      -e "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no" \
                      ./ deploy@$(VULTR_HOST):/opt/gdpr-backend/
                  displayName: 'Copy files to server'

                - script: |
                    ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no deploy@$(VULTR_HOST) << EOF
                      set -e
                      cd /opt/gdpr-backend
                      
                      echo "=== Starting deployment ==="
                      
                      # Update .env with secrets
                      echo "Updating environment variables..."
                      grep -v "^STRIPE_SECRET_KEY=" .env > .env.tmp 2>/dev/null || true
                      echo "STRIPE_SECRET_KEY=$(STRIPE_SECRET_KEY)" >> .env.tmp
                      mv .env.tmp .env
                      
                      # Set queue type (postgres = no Redis, redis = with Redis)
                      export QUEUE_TYPE=$(queueType)
                      
                      # Stop and remove old containers
                      echo "Stopping containers..."
                      docker-compose down --remove-orphans || true
                      
                      # Remove any orphan containers that might block
                      docker rm -f $(docker ps -aq --filter "name=gdpr") 2>/dev/null || true
                      
                      # Build with no cache to ensure fresh image
                      echo "Building Docker image..."
                      if [ -n "$(dockerProfile)" ]; then
                        echo "Using profile: $(dockerProfile)"
                        docker-compose --profile $(dockerProfile) build --no-cache --pull
                        docker-compose --profile $(dockerProfile) up -d
                      else
                        echo "Using default profile (PostgreSQL queue)"
                        docker-compose build --no-cache --pull
                        docker-compose up -d
                      fi
                      
                      # Wait for containers to be healthy
                      echo "Waiting for health check..."
                      for i in {1..30}; do
                        if curl -sf http://localhost:3000/api/health > /dev/null 2>&1; then
                          echo "Health check passed!"
                          break
                        fi
                        echo "Waiting... ($i/30)"
                        sleep 2
                      done
                      
                      # Final verification
                      curl -f http://localhost:3000/api/health || exit 1
                      
                      # Show status
                      echo "=== Deployment Status ==="
                      docker-compose ps
                      curl -s http://localhost:3000/api/scanner/queue/stats | jq . || true
                      
                      echo "=== Deployment successful! ==="
                    EOF
                  displayName: 'Deploy with Docker'

                - script: |
                    # Clean up old Docker images
                    ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no deploy@$(VULTR_HOST) << 'EOF'
                      docker image prune -f
                    EOF
                  displayName: 'Cleanup old images'
                  condition: succeeded()
